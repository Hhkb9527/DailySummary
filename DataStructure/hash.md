#### 1）哈希概念
在顺序结构以及平衡树中，元素关键码与其存储位置之间没有映射关系，想要查找一个元素必须要关键码之间进行<font color=green>**多次比较，顺序查找的时间复杂度为O(N)，在平衡二叉搜索树中查找为O(logN)**</font>，搜索的效率取决于关键码的比较次数
但是有没有一种理想的搜索方法可以实现不用关键码之间的对比从而找到一个元素呢？
方法就是<font color=green>**构造某种函数来建立关键码和存储位置之间的映射的关系，在我们查找某个值的时候就可以通过这个函数直接找到值的存储位置**</font>

**当插入一个元素时：**
根据插入元素的关键码，用这个函数计算出插入元素的存储位置，将其存储

**当搜索一个元素时：**
同样的方法找到关键码的存储位置，取出元素进行对比，关键码相同说明搜索成功，否则失败

<font color=green>**该种方式就是哈希（散列）方法，哈希方法使用的转换函数称为哈希（散列）函数，构造出来的结构称为哈希表（Hash Table）或叫做散列表**</font>
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190912185454568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODYwODUy,size_16,color_FFFFFF,t_70)

#### 2）哈希冲突
使用该方法搜索没有了关键码之间的多次比较，因此搜索效率高，但是存在的问题也是很明显的，我向哈希表中存储数据44，那么44将存储在哪里呢？？这将会造成**哈希冲突**

<font color=green>**不同的关键字经过相同的哈希函数计算得到相同的哈希地址，这种现象称为哈希冲突或者哈希碰撞**</font>，把具有不同关键码却具有相同哈希地址的数据元素称为"同义词"

#### 3）常见哈希函数
**1）直接定制法：**
取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B
优点：简单、均匀
缺点：需要事先知道关键字的分布情况
使用场景：适合查找范围比较小且连续的情况

**2）除留余数法：**
设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，按照哈希函
数：Hash(key) = key% p(p<=m)，将关键码转换成哈希地址

除此外还有：平方取中法、折叠法、随机数法、数学分析法等...

#### 4）哈希冲突的解决
解决哈希冲突两种常见的方法是：**闭散列和开散列**

##### 1、闭散列
也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的"下一个"空位置中去

<font color=blue size=4>**那么如何找寻下一个位置呢？**</font>
<font color=blue>**1）线性探测**：</font>
比如针对上图中的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，hashAddr为4，因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突
**线性探测**将会从发生冲突的位置开始依次向后寻找，直到找到第一个空位置为止

**插入：**
通过哈希函数获取待插入元素在哈希表中的位置，如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190912192148351.png)
**删除：**
采用闭散列解决哈希冲突时，不能直接物理删除哈希表中已有的元素，因为这样会为查找其它元素带来麻烦
例如我删除元素4时采用物理删除的方式，然后我查找元素44，会出现问题，因为我首先找到的是4的地址位置，4地址位置没有元素我将不继续查找，因此查找不到元素44
因此<font color=green>**线性探测采用标记的伪删除法来删除一个元素**</font>

```cpp
// 哈希表每个空间给个标记
// EMPTY标记此位置空， EXIST标记此位置已经有元素， DELETE标记元素已经删除
enum State{EMPTY, EXIST, DELETE}
```

**扩容&&哈希负载因子：**
随着哈希表中的数据增多，出现哈希冲突的概率也就会越大，因此我们为了减少哈希冲突应该保持哈希表中的有效元素少于<font color=green>总容量的70%左右</font>，0.7就是哈希负载因子

**线性探测的缺点：** 一旦发生哈希冲突，所有的冲突连在一起，<font color=green>**容易产生数据"堆积"**</font>，使我们找某个关键码的时候要比较很多次，导致搜索效率降低

<font color=blue>**2）二次探测**</font>
线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免堆积问题，找下一个空位置的方法为
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190912211409877.png)
其中：i = 1,2,3…， H0是通过散列函数Hash(x)对元素的关键码 key 进行计算得到的位置，m是表的大小
#### 2、开散列
开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，<font color=green>**各个桶中的元素通过一个单链表链接起来**</font>，各链表的头结点存储在哈希表中，<font color=green>**开散列中每个桶中放的都是发生哈希冲突的元素**</font>
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190912210412774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODYwODUy,size_16,color_FFFFFF,t_70)
**开散列的扩容**
桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希表进行增容，那该条件怎么确认呢？
开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，给哈希表增容

<font color=blue>**开散列与闭散列比较**</font>
应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销。
事实上： 由于开放地址法必须保持大量的空闲空间以确保搜索效率，如二次探查法要求装载因子a <= 0.7，而表项所占空间又比指针大的多，所以使用链地址法反而比开地址法节省存储空间